/* 
 * Crossbar
 *
 * The Crossbar APIs
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// AWS API settings
    /// </summary>
    [DataContract]
    public partial class StorageAttachmentAwsSettings :  IEquatable<StorageAttachmentAwsSettings>, IValidatableObject
    {
        /// <summary>
        /// how to access the host.
        /// </summary>
        /// <value>how to access the host.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum BucketAccessMethodEnum
        {
            
            /// <summary>
            /// Enum Auto for value: auto
            /// </summary>
            [EnumMember(Value = "auto")]
            Auto = 1,
            
            /// <summary>
            /// Enum Vhost for value: vhost
            /// </summary>
            [EnumMember(Value = "vhost")]
            Vhost = 2,
            
            /// <summary>
            /// Enum Path for value: path
            /// </summary>
            [EnumMember(Value = "path")]
            Path = 3
        }

        /// <summary>
        /// how to access the host.
        /// </summary>
        /// <value>how to access the host.</value>
        [DataMember(Name="bucket_access_method", EmitDefaultValue=false)]
        public BucketAccessMethodEnum? BucketAccessMethod { get; set; }
        /// <summary>
        /// scheme to use to access host
        /// </summary>
        /// <value>scheme to use to access host</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum SchemeEnum
        {
            
            /// <summary>
            /// Enum Http for value: http
            /// </summary>
            [EnumMember(Value = "http")]
            Http = 1,
            
            /// <summary>
            /// Enum Https for value: https
            /// </summary>
            [EnumMember(Value = "https")]
            Https = 2
        }

        /// <summary>
        /// scheme to use to access host
        /// </summary>
        /// <value>scheme to use to access host</value>
        [DataMember(Name="scheme", EmitDefaultValue=false)]
        public SchemeEnum? Scheme { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="StorageAttachmentAwsSettings" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected StorageAttachmentAwsSettings() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="StorageAttachmentAwsSettings" /> class.
        /// </summary>
        /// <param name="bucket">Bucket name to store data to (required).</param>
        /// <param name="bucketAccessMethod">how to access the host..</param>
        /// <param name="bucketAfterHost">use bucket after host as part of url.</param>
        /// <param name="host">the s3 host, leave empty for default.</param>
        /// <param name="key">AWS Key to use (required).</param>
        /// <param name="port">port to use.</param>
        /// <param name="region">the region where the bucket is located.</param>
        /// <param name="scheme">scheme to use to access host.</param>
        /// <param name="secret">AWS Secret to use (required).</param>
        public StorageAttachmentAwsSettings(string bucket = default(string), BucketAccessMethodEnum? bucketAccessMethod = default(BucketAccessMethodEnum?), bool? bucketAfterHost = default(bool?), string host = default(string), string key = default(string), int? port = default(int?), string region = default(string), SchemeEnum? scheme = default(SchemeEnum?), string secret = default(string))
        {
            // to ensure "bucket" is required (not null)
            if (bucket == null)
            {
                throw new InvalidDataException("bucket is a required property for StorageAttachmentAwsSettings and cannot be null");
            }
            else
            {
                this.Bucket = bucket;
            }
            // to ensure "key" is required (not null)
            if (key == null)
            {
                throw new InvalidDataException("key is a required property for StorageAttachmentAwsSettings and cannot be null");
            }
            else
            {
                this.Key = key;
            }
            // to ensure "secret" is required (not null)
            if (secret == null)
            {
                throw new InvalidDataException("secret is a required property for StorageAttachmentAwsSettings and cannot be null");
            }
            else
            {
                this.Secret = secret;
            }
            this.BucketAccessMethod = bucketAccessMethod;
            this.BucketAfterHost = bucketAfterHost;
            this.Host = host;
            this.Port = port;
            this.Region = region;
            this.Scheme = scheme;
        }
        
        /// <summary>
        /// Bucket name to store data to
        /// </summary>
        /// <value>Bucket name to store data to</value>
        [DataMember(Name="bucket", EmitDefaultValue=false)]
        public string Bucket { get; set; }


        /// <summary>
        /// use bucket after host as part of url
        /// </summary>
        /// <value>use bucket after host as part of url</value>
        [DataMember(Name="bucket_after_host", EmitDefaultValue=false)]
        public bool? BucketAfterHost { get; set; }

        /// <summary>
        /// the s3 host, leave empty for default
        /// </summary>
        /// <value>the s3 host, leave empty for default</value>
        [DataMember(Name="host", EmitDefaultValue=false)]
        public string Host { get; set; }

        /// <summary>
        /// AWS Key to use
        /// </summary>
        /// <value>AWS Key to use</value>
        [DataMember(Name="key", EmitDefaultValue=false)]
        public string Key { get; set; }

        /// <summary>
        /// port to use
        /// </summary>
        /// <value>port to use</value>
        [DataMember(Name="port", EmitDefaultValue=false)]
        public int? Port { get; set; }

        /// <summary>
        /// the region where the bucket is located
        /// </summary>
        /// <value>the region where the bucket is located</value>
        [DataMember(Name="region", EmitDefaultValue=false)]
        public string Region { get; set; }


        /// <summary>
        /// AWS Secret to use
        /// </summary>
        /// <value>AWS Secret to use</value>
        [DataMember(Name="secret", EmitDefaultValue=false)]
        public string Secret { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class StorageAttachmentAwsSettings {\n");
            sb.Append("  Bucket: ").Append(Bucket).Append("\n");
            sb.Append("  BucketAccessMethod: ").Append(BucketAccessMethod).Append("\n");
            sb.Append("  BucketAfterHost: ").Append(BucketAfterHost).Append("\n");
            sb.Append("  Host: ").Append(Host).Append("\n");
            sb.Append("  Key: ").Append(Key).Append("\n");
            sb.Append("  Port: ").Append(Port).Append("\n");
            sb.Append("  Region: ").Append(Region).Append("\n");
            sb.Append("  Scheme: ").Append(Scheme).Append("\n");
            sb.Append("  Secret: ").Append(Secret).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as StorageAttachmentAwsSettings);
        }

        /// <summary>
        /// Returns true if StorageAttachmentAwsSettings instances are equal
        /// </summary>
        /// <param name="input">Instance of StorageAttachmentAwsSettings to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(StorageAttachmentAwsSettings input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Bucket == input.Bucket ||
                    (this.Bucket != null &&
                    this.Bucket.Equals(input.Bucket))
                ) && 
                (
                    this.BucketAccessMethod == input.BucketAccessMethod ||
                    (this.BucketAccessMethod != null &&
                    this.BucketAccessMethod.Equals(input.BucketAccessMethod))
                ) && 
                (
                    this.BucketAfterHost == input.BucketAfterHost ||
                    (this.BucketAfterHost != null &&
                    this.BucketAfterHost.Equals(input.BucketAfterHost))
                ) && 
                (
                    this.Host == input.Host ||
                    (this.Host != null &&
                    this.Host.Equals(input.Host))
                ) && 
                (
                    this.Key == input.Key ||
                    (this.Key != null &&
                    this.Key.Equals(input.Key))
                ) && 
                (
                    this.Port == input.Port ||
                    (this.Port != null &&
                    this.Port.Equals(input.Port))
                ) && 
                (
                    this.Region == input.Region ||
                    (this.Region != null &&
                    this.Region.Equals(input.Region))
                ) && 
                (
                    this.Scheme == input.Scheme ||
                    (this.Scheme != null &&
                    this.Scheme.Equals(input.Scheme))
                ) && 
                (
                    this.Secret == input.Secret ||
                    (this.Secret != null &&
                    this.Secret.Equals(input.Secret))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Bucket != null)
                    hashCode = hashCode * 59 + this.Bucket.GetHashCode();
                if (this.BucketAccessMethod != null)
                    hashCode = hashCode * 59 + this.BucketAccessMethod.GetHashCode();
                if (this.BucketAfterHost != null)
                    hashCode = hashCode * 59 + this.BucketAfterHost.GetHashCode();
                if (this.Host != null)
                    hashCode = hashCode * 59 + this.Host.GetHashCode();
                if (this.Key != null)
                    hashCode = hashCode * 59 + this.Key.GetHashCode();
                if (this.Port != null)
                    hashCode = hashCode * 59 + this.Port.GetHashCode();
                if (this.Region != null)
                    hashCode = hashCode * 59 + this.Region.GetHashCode();
                if (this.Scheme != null)
                    hashCode = hashCode * 59 + this.Scheme.GetHashCode();
                if (this.Secret != null)
                    hashCode = hashCode * 59 + this.Secret.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Bucket (string) maxLength
            if(this.Bucket != null && this.Bucket.Length > 63)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Bucket, length must be less than 63.", new [] { "Bucket" });
            }

            // Bucket (string) minLength
            if(this.Bucket != null && this.Bucket.Length < 6)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Bucket, length must be greater than 6.", new [] { "Bucket" });
            }

            // Bucket (string) pattern
            Regex regexBucket = new Regex(@"^[^\\s]*$", RegexOptions.CultureInvariant);
            if (false == regexBucket.Match(this.Bucket).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Bucket, must match a pattern of " + regexBucket, new [] { "Bucket" });
            }

            // Host (string) minLength
            if(this.Host != null && this.Host.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Host, length must be greater than 1.", new [] { "Host" });
            }

            // Host (string) pattern
            Regex regexHost = new Regex(@"^[^\\s]*$", RegexOptions.CultureInvariant);
            if (false == regexHost.Match(this.Host).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Host, must match a pattern of " + regexHost, new [] { "Host" });
            }

            // Key (string) maxLength
            if(this.Key != null && this.Key.Length > 128)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Key, length must be less than 128.", new [] { "Key" });
            }

            // Key (string) minLength
            if(this.Key != null && this.Key.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Key, length must be greater than 1.", new [] { "Key" });
            }

            // Key (string) pattern
            Regex regexKey = new Regex(@"^[^\\s]*$", RegexOptions.CultureInvariant);
            if (false == regexKey.Match(this.Key).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Key, must match a pattern of " + regexKey, new [] { "Key" });
            }

            // Region (string) minLength
            if(this.Region != null && this.Region.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Region, length must be greater than 1.", new [] { "Region" });
            }

            // Region (string) pattern
            Regex regexRegion = new Regex(@"^[^\\s]*$", RegexOptions.CultureInvariant);
            if (false == regexRegion.Match(this.Region).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Region, must match a pattern of " + regexRegion, new [] { "Region" });
            }

            // Secret (string) maxLength
            if(this.Secret != null && this.Secret.Length > 128)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Secret, length must be less than 128.", new [] { "Secret" });
            }

            // Secret (string) minLength
            if(this.Secret != null && this.Secret.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Secret, length must be greater than 1.", new [] { "Secret" });
            }

            // Secret (string) pattern
            Regex regexSecret = new Regex(@"^[^\\s]*$", RegexOptions.CultureInvariant);
            if (false == regexSecret.Match(this.Secret).Success)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Secret, must match a pattern of " + regexSecret, new [] { "Secret" });
            }

            yield break;
        }
    }

}
