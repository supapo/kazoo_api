/* 
 * Crossbar
 *
 * The Crossbar APIs
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// Schema for a temporal rules
    /// </summary>
    [DataContract]
    public partial class TemporalRules :  IEquatable<TemporalRules>, IValidatableObject
    {
        /// <summary>
        /// The recurrence cycle for this rule
        /// </summary>
        /// <value>The recurrence cycle for this rule</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum CycleEnum
        {
            
            /// <summary>
            /// Enum Date for value: date
            /// </summary>
            [EnumMember(Value = "date")]
            Date = 1,
            
            /// <summary>
            /// Enum Daily for value: daily
            /// </summary>
            [EnumMember(Value = "daily")]
            Daily = 2,
            
            /// <summary>
            /// Enum Weekly for value: weekly
            /// </summary>
            [EnumMember(Value = "weekly")]
            Weekly = 3,
            
            /// <summary>
            /// Enum Monthly for value: monthly
            /// </summary>
            [EnumMember(Value = "monthly")]
            Monthly = 4,
            
            /// <summary>
            /// Enum Yearly for value: yearly
            /// </summary>
            [EnumMember(Value = "yearly")]
            Yearly = 5
        }

        /// <summary>
        /// The recurrence cycle for this rule
        /// </summary>
        /// <value>The recurrence cycle for this rule</value>
        [DataMember(Name="cycle", EmitDefaultValue=false)]
        public CycleEnum Cycle { get; set; }
        /// <summary>
        /// The recurrence ordinal for this rule
        /// </summary>
        /// <value>The recurrence ordinal for this rule</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum OrdinalEnum
        {
            
            /// <summary>
            /// Enum Every for value: every
            /// </summary>
            [EnumMember(Value = "every")]
            Every = 1,
            
            /// <summary>
            /// Enum First for value: first
            /// </summary>
            [EnumMember(Value = "first")]
            First = 2,
            
            /// <summary>
            /// Enum Second for value: second
            /// </summary>
            [EnumMember(Value = "second")]
            Second = 3,
            
            /// <summary>
            /// Enum Third for value: third
            /// </summary>
            [EnumMember(Value = "third")]
            Third = 4,
            
            /// <summary>
            /// Enum Fourth for value: fourth
            /// </summary>
            [EnumMember(Value = "fourth")]
            Fourth = 5,
            
            /// <summary>
            /// Enum Fifth for value: fifth
            /// </summary>
            [EnumMember(Value = "fifth")]
            Fifth = 6,
            
            /// <summary>
            /// Enum Last for value: last
            /// </summary>
            [EnumMember(Value = "last")]
            Last = 7
        }

        /// <summary>
        /// The recurrence ordinal for this rule
        /// </summary>
        /// <value>The recurrence ordinal for this rule</value>
        [DataMember(Name="ordinal", EmitDefaultValue=false)]
        public OrdinalEnum? Ordinal { get; set; }
        /// <summary>
        /// Defines Wdays
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum WdaysEnum
        {
            
            /// <summary>
            /// Enum Monday for value: monday
            /// </summary>
            [EnumMember(Value = "monday")]
            Monday = 1,
            
            /// <summary>
            /// Enum Tuesday for value: tuesday
            /// </summary>
            [EnumMember(Value = "tuesday")]
            Tuesday = 2,
            
            /// <summary>
            /// Enum Wednesday for value: wednesday
            /// </summary>
            [EnumMember(Value = "wednesday")]
            Wednesday = 3,
            
            /// <summary>
            /// Enum Wensday for value: wensday
            /// </summary>
            [EnumMember(Value = "wensday")]
            Wensday = 4,
            
            /// <summary>
            /// Enum Thursday for value: thursday
            /// </summary>
            [EnumMember(Value = "thursday")]
            Thursday = 5,
            
            /// <summary>
            /// Enum Friday for value: friday
            /// </summary>
            [EnumMember(Value = "friday")]
            Friday = 6,
            
            /// <summary>
            /// Enum Saturday for value: saturday
            /// </summary>
            [EnumMember(Value = "saturday")]
            Saturday = 7,
            
            /// <summary>
            /// Enum Sunday for value: sunday
            /// </summary>
            [EnumMember(Value = "sunday")]
            Sunday = 8
        }


        /// <summary>
        /// The recurrence weekdays for this rule
        /// </summary>
        /// <value>The recurrence weekdays for this rule</value>
        [DataMember(Name="wdays", EmitDefaultValue=false)]
        public List<WdaysEnum> Wdays { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="TemporalRules" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TemporalRules() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TemporalRules" /> class.
        /// </summary>
        /// <param name="cycle">The recurrence cycle for this rule (required).</param>
        /// <param name="days">The recurrence days for this rule.</param>
        /// <param name="enabled">Whether the rule is enabled.</param>
        /// <param name="flags">Flags set by external applications.</param>
        /// <param name="interval">The recurrence interval for this rule.</param>
        /// <param name="month">The recurrence month for this rule.</param>
        /// <param name="name">A friendly name for the temporal rule (required).</param>
        /// <param name="ordinal">The recurrence ordinal for this rule.</param>
        /// <param name="startDate">The date that any recurrence should be calculated as starting on.</param>
        /// <param name="timeWindowStart">Seconds from the start of a day to consider this rule valid.</param>
        /// <param name="timeWindowStop">Seconds from the start of a day to stop considering this rule valid.</param>
        /// <param name="wdays">The recurrence weekdays for this rule.</param>
        public TemporalRules(CycleEnum cycle = default(CycleEnum), List<int?> days = default(List<int?>), bool? enabled = default(bool?), List<string> flags = default(List<string>), int? interval = default(int?), int? month = default(int?), string name = default(string), OrdinalEnum? ordinal = default(OrdinalEnum?), int? startDate = default(int?), int? timeWindowStart = default(int?), int? timeWindowStop = default(int?), List<WdaysEnum> wdays = default(List<WdaysEnum>))
        {
            // to ensure "cycle" is required (not null)
            if (cycle == null)
            {
                throw new InvalidDataException("cycle is a required property for TemporalRules and cannot be null");
            }
            else
            {
                this.Cycle = cycle;
            }
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new InvalidDataException("name is a required property for TemporalRules and cannot be null");
            }
            else
            {
                this.Name = name;
            }
            this.Days = days;
            this.Enabled = enabled;
            this.Flags = flags;
            this.Interval = interval;
            this.Month = month;
            this.Ordinal = ordinal;
            this.StartDate = startDate;
            this.TimeWindowStart = timeWindowStart;
            this.TimeWindowStop = timeWindowStop;
            this.Wdays = wdays;
        }
        

        /// <summary>
        /// The recurrence days for this rule
        /// </summary>
        /// <value>The recurrence days for this rule</value>
        [DataMember(Name="days", EmitDefaultValue=false)]
        public List<int?> Days { get; set; }

        /// <summary>
        /// Whether the rule is enabled
        /// </summary>
        /// <value>Whether the rule is enabled</value>
        [DataMember(Name="enabled", EmitDefaultValue=false)]
        public bool? Enabled { get; set; }

        /// <summary>
        /// Flags set by external applications
        /// </summary>
        /// <value>Flags set by external applications</value>
        [DataMember(Name="flags", EmitDefaultValue=false)]
        public List<string> Flags { get; set; }

        /// <summary>
        /// The recurrence interval for this rule
        /// </summary>
        /// <value>The recurrence interval for this rule</value>
        [DataMember(Name="interval", EmitDefaultValue=false)]
        public int? Interval { get; set; }

        /// <summary>
        /// The recurrence month for this rule
        /// </summary>
        /// <value>The recurrence month for this rule</value>
        [DataMember(Name="month", EmitDefaultValue=false)]
        public int? Month { get; set; }

        /// <summary>
        /// A friendly name for the temporal rule
        /// </summary>
        /// <value>A friendly name for the temporal rule</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }


        /// <summary>
        /// The date that any recurrence should be calculated as starting on
        /// </summary>
        /// <value>The date that any recurrence should be calculated as starting on</value>
        [DataMember(Name="start_date", EmitDefaultValue=false)]
        public int? StartDate { get; set; }

        /// <summary>
        /// Seconds from the start of a day to consider this rule valid
        /// </summary>
        /// <value>Seconds from the start of a day to consider this rule valid</value>
        [DataMember(Name="time_window_start", EmitDefaultValue=false)]
        public int? TimeWindowStart { get; set; }

        /// <summary>
        /// Seconds from the start of a day to stop considering this rule valid
        /// </summary>
        /// <value>Seconds from the start of a day to stop considering this rule valid</value>
        [DataMember(Name="time_window_stop", EmitDefaultValue=false)]
        public int? TimeWindowStop { get; set; }


        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class TemporalRules {\n");
            sb.Append("  Cycle: ").Append(Cycle).Append("\n");
            sb.Append("  Days: ").Append(Days).Append("\n");
            sb.Append("  Enabled: ").Append(Enabled).Append("\n");
            sb.Append("  Flags: ").Append(Flags).Append("\n");
            sb.Append("  Interval: ").Append(Interval).Append("\n");
            sb.Append("  Month: ").Append(Month).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Ordinal: ").Append(Ordinal).Append("\n");
            sb.Append("  StartDate: ").Append(StartDate).Append("\n");
            sb.Append("  TimeWindowStart: ").Append(TimeWindowStart).Append("\n");
            sb.Append("  TimeWindowStop: ").Append(TimeWindowStop).Append("\n");
            sb.Append("  Wdays: ").Append(Wdays).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TemporalRules);
        }

        /// <summary>
        /// Returns true if TemporalRules instances are equal
        /// </summary>
        /// <param name="input">Instance of TemporalRules to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TemporalRules input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Cycle == input.Cycle ||
                    (this.Cycle != null &&
                    this.Cycle.Equals(input.Cycle))
                ) && 
                (
                    this.Days == input.Days ||
                    this.Days != null &&
                    this.Days.SequenceEqual(input.Days)
                ) && 
                (
                    this.Enabled == input.Enabled ||
                    (this.Enabled != null &&
                    this.Enabled.Equals(input.Enabled))
                ) && 
                (
                    this.Flags == input.Flags ||
                    this.Flags != null &&
                    this.Flags.SequenceEqual(input.Flags)
                ) && 
                (
                    this.Interval == input.Interval ||
                    (this.Interval != null &&
                    this.Interval.Equals(input.Interval))
                ) && 
                (
                    this.Month == input.Month ||
                    (this.Month != null &&
                    this.Month.Equals(input.Month))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Ordinal == input.Ordinal ||
                    (this.Ordinal != null &&
                    this.Ordinal.Equals(input.Ordinal))
                ) && 
                (
                    this.StartDate == input.StartDate ||
                    (this.StartDate != null &&
                    this.StartDate.Equals(input.StartDate))
                ) && 
                (
                    this.TimeWindowStart == input.TimeWindowStart ||
                    (this.TimeWindowStart != null &&
                    this.TimeWindowStart.Equals(input.TimeWindowStart))
                ) && 
                (
                    this.TimeWindowStop == input.TimeWindowStop ||
                    (this.TimeWindowStop != null &&
                    this.TimeWindowStop.Equals(input.TimeWindowStop))
                ) && 
                (
                    this.Wdays == input.Wdays ||
                    this.Wdays != null &&
                    this.Wdays.SequenceEqual(input.Wdays)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Cycle != null)
                    hashCode = hashCode * 59 + this.Cycle.GetHashCode();
                if (this.Days != null)
                    hashCode = hashCode * 59 + this.Days.GetHashCode();
                if (this.Enabled != null)
                    hashCode = hashCode * 59 + this.Enabled.GetHashCode();
                if (this.Flags != null)
                    hashCode = hashCode * 59 + this.Flags.GetHashCode();
                if (this.Interval != null)
                    hashCode = hashCode * 59 + this.Interval.GetHashCode();
                if (this.Month != null)
                    hashCode = hashCode * 59 + this.Month.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.Ordinal != null)
                    hashCode = hashCode * 59 + this.Ordinal.GetHashCode();
                if (this.StartDate != null)
                    hashCode = hashCode * 59 + this.StartDate.GetHashCode();
                if (this.TimeWindowStart != null)
                    hashCode = hashCode * 59 + this.TimeWindowStart.GetHashCode();
                if (this.TimeWindowStop != null)
                    hashCode = hashCode * 59 + this.TimeWindowStop.GetHashCode();
                if (this.Wdays != null)
                    hashCode = hashCode * 59 + this.Wdays.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // Interval (int?) minimum
            if(this.Interval < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Interval, must be a value greater than or equal to 1.", new [] { "Interval" });
            }

            // Month (int?) maximum
            if(this.Month > (int?)12)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Month, must be a value less than or equal to 12.", new [] { "Month" });
            }

            // Month (int?) minimum
            if(this.Month < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Month, must be a value greater than or equal to 1.", new [] { "Month" });
            }

            // Name (string) maxLength
            if(this.Name != null && this.Name.Length > 128)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Name, length must be less than 128.", new [] { "Name" });
            }

            // Name (string) minLength
            if(this.Name != null && this.Name.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Name, length must be greater than 1.", new [] { "Name" });
            }

            // TimeWindowStart (int?) maximum
            if(this.TimeWindowStart > (int?)86400)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TimeWindowStart, must be a value less than or equal to 86400.", new [] { "TimeWindowStart" });
            }

            // TimeWindowStart (int?) minimum
            if(this.TimeWindowStart < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TimeWindowStart, must be a value greater than or equal to 0.", new [] { "TimeWindowStart" });
            }

            // TimeWindowStop (int?) maximum
            if(this.TimeWindowStop > (int?)86400)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TimeWindowStop, must be a value less than or equal to 86400.", new [] { "TimeWindowStop" });
            }

            // TimeWindowStop (int?) minimum
            if(this.TimeWindowStop < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for TimeWindowStop, must be a value greater than or equal to 0.", new [] { "TimeWindowStop" });
            }

            yield break;
        }
    }

}
