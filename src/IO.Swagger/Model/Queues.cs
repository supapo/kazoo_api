/* 
 * Crossbar
 *
 * The Crossbar APIs
 *
 * OpenAPI spec version: v2
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// Call Queues - FIFO call queues for serializing callers connecting to agents
    /// </summary>
    [DataContract]
    public partial class Queues :  IEquatable<Queues>, IValidatableObject
    {
        /// <summary>
        /// Key caller can press while on hold to exit the queue and continue in the callflow
        /// </summary>
        /// <value>Key caller can press while on hold to exit the queue and continue in the callflow</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum CallerExitKeyEnum
        {
            
            /// <summary>
            /// Enum _1 for value: 1
            /// </summary>
            [EnumMember(Value = "1")]
            _1 = 1,
            
            /// <summary>
            /// Enum _2 for value: 2
            /// </summary>
            [EnumMember(Value = "2")]
            _2 = 2,
            
            /// <summary>
            /// Enum _3 for value: 3
            /// </summary>
            [EnumMember(Value = "3")]
            _3 = 3,
            
            /// <summary>
            /// Enum _4 for value: 4
            /// </summary>
            [EnumMember(Value = "4")]
            _4 = 4,
            
            /// <summary>
            /// Enum _5 for value: 5
            /// </summary>
            [EnumMember(Value = "5")]
            _5 = 5,
            
            /// <summary>
            /// Enum _6 for value: 6
            /// </summary>
            [EnumMember(Value = "6")]
            _6 = 6,
            
            /// <summary>
            /// Enum _7 for value: 7
            /// </summary>
            [EnumMember(Value = "7")]
            _7 = 7,
            
            /// <summary>
            /// Enum _8 for value: 8
            /// </summary>
            [EnumMember(Value = "8")]
            _8 = 8,
            
            /// <summary>
            /// Enum _9 for value: 9
            /// </summary>
            [EnumMember(Value = "9")]
            _9 = 9,
            
            /// <summary>
            /// Enum Star for value: *
            /// </summary>
            [EnumMember(Value = "*")]
            Star = 10,
            
            /// <summary>
            /// Enum _0 for value: 0
            /// </summary>
            [EnumMember(Value = "0")]
            _0 = 11,
            
            /// <summary>
            /// Enum Hash for value: #
            /// </summary>
            [EnumMember(Value = "#")]
            Hash = 12
        }

        /// <summary>
        /// Key caller can press while on hold to exit the queue and continue in the callflow
        /// </summary>
        /// <value>Key caller can press while on hold to exit the queue and continue in the callflow</value>
        [DataMember(Name="caller_exit_key", EmitDefaultValue=false)]
        public CallerExitKeyEnum? CallerExitKey { get; set; }
        /// <summary>
        /// The queue strategy for connecting agents to callers
        /// </summary>
        /// <value>The queue strategy for connecting agents to callers</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum StrategyEnum
        {
            
            /// <summary>
            /// Enum Roundrobin for value: round_robin
            /// </summary>
            [EnumMember(Value = "round_robin")]
            Roundrobin = 1,
            
            /// <summary>
            /// Enum Mostidle for value: most_idle
            /// </summary>
            [EnumMember(Value = "most_idle")]
            Mostidle = 2
        }

        /// <summary>
        /// The queue strategy for connecting agents to callers
        /// </summary>
        /// <value>The queue strategy for connecting agents to callers</value>
        [DataMember(Name="strategy", EmitDefaultValue=false)]
        public StrategyEnum? Strategy { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="Queues" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected Queues() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="Queues" /> class.
        /// </summary>
        /// <param name="agentRingTimeout">In seconds, how long to ring an agent before progressing to the next agent available.</param>
        /// <param name="agentWrapupTime">Pre-defined wait period applied after an agent handles a customer call.</param>
        /// <param name="announce">Media ID (or appropriate media URI) of media to play when caller is about to be connected..</param>
        /// <param name="announcements">announcements.</param>
        /// <param name="callerExitKey">Key caller can press while on hold to exit the queue and continue in the callflow (default to CallerExitKeyEnum.Hash).</param>
        /// <param name="cdrUrl">An optional HTTP URL to POST the CDR.</param>
        /// <param name="connectionTimeout">In seconds, how long to try to connect the caller before progressing past the queue callflow action.</param>
        /// <param name="enterWhenEmpty">Allows a caller to enter a queue and wait when no agents are available (default to true).</param>
        /// <param name="maxPriority">Maximum possible priority level queue will support. Can not be redefined for existing queue..</param>
        /// <param name="maxQueueSize">How many callers are allowed to wait on hold in the queue (0 for no limit).</param>
        /// <param name="moh">Media ID (or appropriate media URI) of media to play while caller is on hold..</param>
        /// <param name="name">A friendly name for the queue (required).</param>
        /// <param name="recordCaller">When enabled, a caller&#39;s audio will be recorded (default to false).</param>
        /// <param name="recordingUrl">An optional HTTP URL to PUT the call recording after the call ends (and should respond to GET for retrieving the audio data).</param>
        /// <param name="ringSimultaneously">The number of agents to try in parallel when connecting a caller.</param>
        /// <param name="strategy">The queue strategy for connecting agents to callers (default to StrategyEnum.Roundrobin).</param>
        public Queues(int? agentRingTimeout = default(int?), int? agentWrapupTime = default(int?), string announce = default(string), QueuesAnnouncements announcements = default(QueuesAnnouncements), CallerExitKeyEnum? callerExitKey = CallerExitKeyEnum.Hash, string cdrUrl = default(string), int? connectionTimeout = default(int?), bool? enterWhenEmpty = true, int? maxPriority = default(int?), int? maxQueueSize = default(int?), string moh = default(string), string name = default(string), bool? recordCaller = false, string recordingUrl = default(string), int? ringSimultaneously = default(int?), StrategyEnum? strategy = StrategyEnum.Roundrobin)
        {
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new InvalidDataException("name is a required property for Queues and cannot be null");
            }
            else
            {
                this.Name = name;
            }
            this.AgentRingTimeout = agentRingTimeout;
            this.AgentWrapupTime = agentWrapupTime;
            this.Announce = announce;
            this.Announcements = announcements;
            // use default value if no "callerExitKey" provided
            if (callerExitKey == null)
            {
                this.CallerExitKey = CallerExitKeyEnum.Hash;
            }
            else
            {
                this.CallerExitKey = callerExitKey;
            }
            this.CdrUrl = cdrUrl;
            this.ConnectionTimeout = connectionTimeout;
            // use default value if no "enterWhenEmpty" provided
            if (enterWhenEmpty == null)
            {
                this.EnterWhenEmpty = true;
            }
            else
            {
                this.EnterWhenEmpty = enterWhenEmpty;
            }
            this.MaxPriority = maxPriority;
            this.MaxQueueSize = maxQueueSize;
            this.Moh = moh;
            // use default value if no "recordCaller" provided
            if (recordCaller == null)
            {
                this.RecordCaller = false;
            }
            else
            {
                this.RecordCaller = recordCaller;
            }
            this.RecordingUrl = recordingUrl;
            this.RingSimultaneously = ringSimultaneously;
            // use default value if no "strategy" provided
            if (strategy == null)
            {
                this.Strategy = StrategyEnum.Roundrobin;
            }
            else
            {
                this.Strategy = strategy;
            }
        }
        
        /// <summary>
        /// In seconds, how long to ring an agent before progressing to the next agent available
        /// </summary>
        /// <value>In seconds, how long to ring an agent before progressing to the next agent available</value>
        [DataMember(Name="agent_ring_timeout", EmitDefaultValue=false)]
        public int? AgentRingTimeout { get; set; }

        /// <summary>
        /// Pre-defined wait period applied after an agent handles a customer call
        /// </summary>
        /// <value>Pre-defined wait period applied after an agent handles a customer call</value>
        [DataMember(Name="agent_wrapup_time", EmitDefaultValue=false)]
        public int? AgentWrapupTime { get; set; }

        /// <summary>
        /// Media ID (or appropriate media URI) of media to play when caller is about to be connected.
        /// </summary>
        /// <value>Media ID (or appropriate media URI) of media to play when caller is about to be connected.</value>
        [DataMember(Name="announce", EmitDefaultValue=false)]
        public string Announce { get; set; }

        /// <summary>
        /// Gets or Sets Announcements
        /// </summary>
        [DataMember(Name="announcements", EmitDefaultValue=false)]
        public QueuesAnnouncements Announcements { get; set; }


        /// <summary>
        /// An optional HTTP URL to POST the CDR
        /// </summary>
        /// <value>An optional HTTP URL to POST the CDR</value>
        [DataMember(Name="cdr_url", EmitDefaultValue=false)]
        public string CdrUrl { get; set; }

        /// <summary>
        /// In seconds, how long to try to connect the caller before progressing past the queue callflow action
        /// </summary>
        /// <value>In seconds, how long to try to connect the caller before progressing past the queue callflow action</value>
        [DataMember(Name="connection_timeout", EmitDefaultValue=false)]
        public int? ConnectionTimeout { get; set; }

        /// <summary>
        /// Allows a caller to enter a queue and wait when no agents are available
        /// </summary>
        /// <value>Allows a caller to enter a queue and wait when no agents are available</value>
        [DataMember(Name="enter_when_empty", EmitDefaultValue=false)]
        public bool? EnterWhenEmpty { get; set; }

        /// <summary>
        /// Maximum possible priority level queue will support. Can not be redefined for existing queue.
        /// </summary>
        /// <value>Maximum possible priority level queue will support. Can not be redefined for existing queue.</value>
        [DataMember(Name="max_priority", EmitDefaultValue=false)]
        public int? MaxPriority { get; set; }

        /// <summary>
        /// How many callers are allowed to wait on hold in the queue (0 for no limit)
        /// </summary>
        /// <value>How many callers are allowed to wait on hold in the queue (0 for no limit)</value>
        [DataMember(Name="max_queue_size", EmitDefaultValue=false)]
        public int? MaxQueueSize { get; set; }

        /// <summary>
        /// Media ID (or appropriate media URI) of media to play while caller is on hold.
        /// </summary>
        /// <value>Media ID (or appropriate media URI) of media to play while caller is on hold.</value>
        [DataMember(Name="moh", EmitDefaultValue=false)]
        public string Moh { get; set; }

        /// <summary>
        /// A friendly name for the queue
        /// </summary>
        /// <value>A friendly name for the queue</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// When enabled, a caller&#39;s audio will be recorded
        /// </summary>
        /// <value>When enabled, a caller&#39;s audio will be recorded</value>
        [DataMember(Name="record_caller", EmitDefaultValue=false)]
        public bool? RecordCaller { get; set; }

        /// <summary>
        /// An optional HTTP URL to PUT the call recording after the call ends (and should respond to GET for retrieving the audio data)
        /// </summary>
        /// <value>An optional HTTP URL to PUT the call recording after the call ends (and should respond to GET for retrieving the audio data)</value>
        [DataMember(Name="recording_url", EmitDefaultValue=false)]
        public string RecordingUrl { get; set; }

        /// <summary>
        /// The number of agents to try in parallel when connecting a caller
        /// </summary>
        /// <value>The number of agents to try in parallel when connecting a caller</value>
        [DataMember(Name="ring_simultaneously", EmitDefaultValue=false)]
        public int? RingSimultaneously { get; set; }


        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class Queues {\n");
            sb.Append("  AgentRingTimeout: ").Append(AgentRingTimeout).Append("\n");
            sb.Append("  AgentWrapupTime: ").Append(AgentWrapupTime).Append("\n");
            sb.Append("  Announce: ").Append(Announce).Append("\n");
            sb.Append("  Announcements: ").Append(Announcements).Append("\n");
            sb.Append("  CallerExitKey: ").Append(CallerExitKey).Append("\n");
            sb.Append("  CdrUrl: ").Append(CdrUrl).Append("\n");
            sb.Append("  ConnectionTimeout: ").Append(ConnectionTimeout).Append("\n");
            sb.Append("  EnterWhenEmpty: ").Append(EnterWhenEmpty).Append("\n");
            sb.Append("  MaxPriority: ").Append(MaxPriority).Append("\n");
            sb.Append("  MaxQueueSize: ").Append(MaxQueueSize).Append("\n");
            sb.Append("  Moh: ").Append(Moh).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  RecordCaller: ").Append(RecordCaller).Append("\n");
            sb.Append("  RecordingUrl: ").Append(RecordingUrl).Append("\n");
            sb.Append("  RingSimultaneously: ").Append(RingSimultaneously).Append("\n");
            sb.Append("  Strategy: ").Append(Strategy).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as Queues);
        }

        /// <summary>
        /// Returns true if Queues instances are equal
        /// </summary>
        /// <param name="input">Instance of Queues to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(Queues input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.AgentRingTimeout == input.AgentRingTimeout ||
                    (this.AgentRingTimeout != null &&
                    this.AgentRingTimeout.Equals(input.AgentRingTimeout))
                ) && 
                (
                    this.AgentWrapupTime == input.AgentWrapupTime ||
                    (this.AgentWrapupTime != null &&
                    this.AgentWrapupTime.Equals(input.AgentWrapupTime))
                ) && 
                (
                    this.Announce == input.Announce ||
                    (this.Announce != null &&
                    this.Announce.Equals(input.Announce))
                ) && 
                (
                    this.Announcements == input.Announcements ||
                    (this.Announcements != null &&
                    this.Announcements.Equals(input.Announcements))
                ) && 
                (
                    this.CallerExitKey == input.CallerExitKey ||
                    (this.CallerExitKey != null &&
                    this.CallerExitKey.Equals(input.CallerExitKey))
                ) && 
                (
                    this.CdrUrl == input.CdrUrl ||
                    (this.CdrUrl != null &&
                    this.CdrUrl.Equals(input.CdrUrl))
                ) && 
                (
                    this.ConnectionTimeout == input.ConnectionTimeout ||
                    (this.ConnectionTimeout != null &&
                    this.ConnectionTimeout.Equals(input.ConnectionTimeout))
                ) && 
                (
                    this.EnterWhenEmpty == input.EnterWhenEmpty ||
                    (this.EnterWhenEmpty != null &&
                    this.EnterWhenEmpty.Equals(input.EnterWhenEmpty))
                ) && 
                (
                    this.MaxPriority == input.MaxPriority ||
                    (this.MaxPriority != null &&
                    this.MaxPriority.Equals(input.MaxPriority))
                ) && 
                (
                    this.MaxQueueSize == input.MaxQueueSize ||
                    (this.MaxQueueSize != null &&
                    this.MaxQueueSize.Equals(input.MaxQueueSize))
                ) && 
                (
                    this.Moh == input.Moh ||
                    (this.Moh != null &&
                    this.Moh.Equals(input.Moh))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.RecordCaller == input.RecordCaller ||
                    (this.RecordCaller != null &&
                    this.RecordCaller.Equals(input.RecordCaller))
                ) && 
                (
                    this.RecordingUrl == input.RecordingUrl ||
                    (this.RecordingUrl != null &&
                    this.RecordingUrl.Equals(input.RecordingUrl))
                ) && 
                (
                    this.RingSimultaneously == input.RingSimultaneously ||
                    (this.RingSimultaneously != null &&
                    this.RingSimultaneously.Equals(input.RingSimultaneously))
                ) && 
                (
                    this.Strategy == input.Strategy ||
                    (this.Strategy != null &&
                    this.Strategy.Equals(input.Strategy))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.AgentRingTimeout != null)
                    hashCode = hashCode * 59 + this.AgentRingTimeout.GetHashCode();
                if (this.AgentWrapupTime != null)
                    hashCode = hashCode * 59 + this.AgentWrapupTime.GetHashCode();
                if (this.Announce != null)
                    hashCode = hashCode * 59 + this.Announce.GetHashCode();
                if (this.Announcements != null)
                    hashCode = hashCode * 59 + this.Announcements.GetHashCode();
                if (this.CallerExitKey != null)
                    hashCode = hashCode * 59 + this.CallerExitKey.GetHashCode();
                if (this.CdrUrl != null)
                    hashCode = hashCode * 59 + this.CdrUrl.GetHashCode();
                if (this.ConnectionTimeout != null)
                    hashCode = hashCode * 59 + this.ConnectionTimeout.GetHashCode();
                if (this.EnterWhenEmpty != null)
                    hashCode = hashCode * 59 + this.EnterWhenEmpty.GetHashCode();
                if (this.MaxPriority != null)
                    hashCode = hashCode * 59 + this.MaxPriority.GetHashCode();
                if (this.MaxQueueSize != null)
                    hashCode = hashCode * 59 + this.MaxQueueSize.GetHashCode();
                if (this.Moh != null)
                    hashCode = hashCode * 59 + this.Moh.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.RecordCaller != null)
                    hashCode = hashCode * 59 + this.RecordCaller.GetHashCode();
                if (this.RecordingUrl != null)
                    hashCode = hashCode * 59 + this.RecordingUrl.GetHashCode();
                if (this.RingSimultaneously != null)
                    hashCode = hashCode * 59 + this.RingSimultaneously.GetHashCode();
                if (this.Strategy != null)
                    hashCode = hashCode * 59 + this.Strategy.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // AgentRingTimeout (int?) minimum
            if(this.AgentRingTimeout < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AgentRingTimeout, must be a value greater than or equal to 1.", new [] { "AgentRingTimeout" });
            }

            // AgentWrapupTime (int?) minimum
            if(this.AgentWrapupTime < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for AgentWrapupTime, must be a value greater than or equal to 0.", new [] { "AgentWrapupTime" });
            }

            // ConnectionTimeout (int?) minimum
            if(this.ConnectionTimeout < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for ConnectionTimeout, must be a value greater than or equal to 0.", new [] { "ConnectionTimeout" });
            }

            // MaxPriority (int?) maximum
            if(this.MaxPriority > (int?)255)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for MaxPriority, must be a value less than or equal to 255.", new [] { "MaxPriority" });
            }

            // MaxPriority (int?) minimum
            if(this.MaxPriority < (int?)0)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for MaxPriority, must be a value greater than or equal to 0.", new [] { "MaxPriority" });
            }

            // Name (string) maxLength
            if(this.Name != null && this.Name.Length > 128)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Name, length must be less than 128.", new [] { "Name" });
            }

            // Name (string) minLength
            if(this.Name != null && this.Name.Length < 1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Name, length must be greater than 1.", new [] { "Name" });
            }

            // RingSimultaneously (int?) minimum
            if(this.RingSimultaneously < (int?)1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for RingSimultaneously, must be a value greater than or equal to 1.", new [] { "RingSimultaneously" });
            }

            yield break;
        }
    }

}
